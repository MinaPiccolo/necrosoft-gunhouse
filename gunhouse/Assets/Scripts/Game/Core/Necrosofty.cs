//------------------------------------------------------------------------------
// <auto-generated>
//     Este código foi gerado por uma ferramenta.
//     Versão de Tempo de Execução:4.0.30319.18444
//
//     As alterações a este ficheiro poderão provocar um comportamento incorrecto e perder-se-ão se
//     o código for regenerado.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace Necrosofty
{
    public static class Input
    {
        public enum TouchStatus { None, Down, Up, Move, Canceled }

        public class TouchData
        {
            public float X;
            public float Y;
            public bool hold;
            public TouchStatus Status;
            public int ID;
            public bool Skip;
            public TouchData() { }
        }

        public class Touch
        {
            enum Status { NONE, DOWN, UP, MOVE, CANCELED }

            public static bool hold = false;
            public static Camera c;

            public bool updated;

            public static List<TouchData> GetData(int deviceIndex)
            {
                List<TouchData> result = new List<TouchData>();

                TouchData r = new TouchData();
                Rect rcam = c.pixelRect;

                /*  NOTE(shane): Gunhouse virtual input was originally designed specially for 16:9.
                    The game now supports all kinds of aspect ratios, this has broken the virual input.
                    To correct this we now manually create a 16:9 virual input rather than relying on camera height.
                    To do this we get the camera width and use this to create the virtual height (c.pixelWidth * 9 / 16)

                    Example:
                        On a 4:3 screen you might have a screen of 889x667. With the above correction the virtual input
                        screen will be 889x500

                    Once we have this new virtual input screen, we then need to create an offset to make sure
                    it's located in the center of the screen since that's where the active field is. */
                float customPixelHeight = c.pixelWidth * 9 / 16;
                float inputOffset = (c.pixelHeight - customPixelHeight) * 0.5f;

                float realx = (UnityEngine.Input.mousePosition.x - rcam.xMin) / c.pixelWidth;
                float realy = ((UnityEngine.Input.mousePosition.y - inputOffset) - rcam.yMin) / customPixelHeight;

                r.X = realx - 0.5f;
                r.Y = 0.5f - realy;

                if (hold)
                {
                    r.Status = TouchStatus.Move;
                    r.ID = 0;
                    r.Skip = false;
                    result.Add(r);
                }
                else { r.Status = TouchStatus.None; }

                if (UnityEngine.Input.GetMouseButtonDown(0) || UnityEngine.Input.GetMouseButtonUp(0)) {
                    if (UnityEngine.Input.GetMouseButtonDown(0)) {
                        r.Status = TouchStatus.Down;
                        hold = true;
                    }

                    if (UnityEngine.Input.GetMouseButtonUp(0)) {
                        r.Status = TouchStatus.Up;
                        hold = false;
                    }

                    r.ID = 0;
                    r.Skip = false;
                    result.Add(r);
                }

                return result;
            }
        }
    }

    public static class Math
    {
        public static class Vmath
        {
            public static Vector2 xy(Vector4 v) { return(new Vector2(v.x, v.y)); }

            public static Vector2 Zw(Vector4 v) { return(new Vector2(v.z, v.w)); }
        }

        public class Bounds2
        {
            public Vector2 Point00;
            public Vector2 Point11;
            public Vector2 Point10;
            public Vector2 Point01;
            public Vector2 Center;
            public Vector2 Size;
            public int uv_index;
            private Bounds unityBound;
            public static Bounds2 Quad0_1 = new Bounds2(Vector2.zero, Vector2.one);

            public Bounds2(Vector2 min, Vector2 max)
            {
                this.Point00 = min;
                this.Point11 = max;
                this.Point01 = new Vector2(min.x, max.y);
                this.Point10 = new Vector2(max.x, min.y);
                this.Size = max-min;
                this.unityBound = new Bounds(new Vector3(min.x + this.Size.x / 2.0f, min.y + this.Size.y / 2.0f),
                                             new Vector3(this.Size.x, this.Size.y));
                this.Center = new Vector2(this.unityBound.center.x, this.unityBound.center.y);
            }
        }
    }
}
